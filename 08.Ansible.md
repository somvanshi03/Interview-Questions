# Ansible interview questions 

---

## ðŸ“‹ Table of Contents
- [Basic Ansible Questions](#basic-ansible-questions)
- [Intermediate Ansible Questions](#intermediate-ansible-questions)
- [Advanced Ansible Questions](#advanced-ansible-questions)
- [Ansible Scenario-Based Questions](#ansible-scenario-based-questions)
- [Ansible Commands Cheat Sheet](#ansible-commands-cheat-sheet)

---

## Basic Ansible Questions

### Q1: What is Ansible and what are its primary use cases?

**Answer:**
Ansible is an **open-source automation tool** used for configuration management, application deployment, and task automation . It is designed to be simple to use, with a focus on ease of learning and minimal setup.

**Key characteristics**:
- **Agentless**: Does not require any software to be installed on target machines; uses SSH for Linux/Unix and WinRM for Windows 
- **YAML-based**: Uses human-readable YAML for playbooks 
- **Idempotent**: Ensures consistency by applying changes only when necessary 
- **Push-based**: Control node pushes configurations to managed nodes 

**Primary use cases**:
- **Configuration management**: Keeping servers in a known, consistent state 
- **Application deployment**: Rolling out applications across environments without manual steps 
- **Orchestration**: Coordinating complex workflows like zero-downtime updates 
- **Provisioning**: Bootstrapping new infrastructure, often in cloud environments 

### Q2: How does Ansible differ from other configuration management tools like Puppet or Chef?

**Answer:**
The key difference is that Ansible is **agentless** . Here's a comparison:

| Aspect | Ansible | Puppet/Chef |
|--------|---------|-------------|
| **Architecture** | Agentless (SSH/WinRM) | Agent-based (requires installed software)  |
| **Language** | YAML (human-readable) | Ruby-based DSL  |
| **Model** | Push-based (control node pushes) | Pull-based (agents pull from master)  |
| **Setup complexity** | Low - no agents to install | Higher - requires agent deployment  |
| **Learning curve** | Gentler - YAML is intuitive | Steeper - requires DSL knowledge |

**Advantages of Ansible's approach**:
- Lower setup overhead 
- Easier for teams just getting started 
- No ongoing maintenance of agent software 
- Works with existing SSH infrastructure 

### Q3: What is an Ansible Playbook?

**Answer:**
An **Ansible Playbook** is a YAML file that defines a set of automation tasks to be executed on managed hosts . Playbooks are the foundation of Ansible's configuration management and deployment capabilities.

**Main components** :
- **Hosts**: Target servers where tasks will run
- **Tasks**: Actions to perform (install packages, copy files, etc.)
- **Vars**: Variables that customize behavior
- **Handlers**: Special tasks triggered by notifications
- **Roles**: Reusable collections of content

**Example playbook**:
```yaml
---
- name: Install and configure web server
  hosts: webservers
  become: yes
  vars:
    http_port: 80
    
  tasks:
    - name: Install nginx
      apt:
        name: nginx
        state: present
        
    - name: Start nginx service
      service:
        name: nginx
        state: started
        enabled: yes
```

### Q4: What is an Ansible Inventory file?

**Answer:**
An **Ansible Inventory** file defines the hosts (servers, network devices, etc.) that Ansible manages . It organizes hosts into groups and can specify connection details.

**Inventory types** :
- **Static inventory**: INI or YAML files that list hosts manually
- **Dynamic inventory**: Scripts or plugins that query external sources (cloud providers, CMDBs)

**Example static inventory (INI format)** :
```ini
[web]
webserver1 ansible_host=192.168.1.11
webserver2 ansible_host=192.168.1.12

[db]
dbserver1 ansible_host=192.168.1.21

[all:vars]
ansible_user=admin
ansible_ssh_private_key_file=/home/user/.ssh/id_rsa
```

### Q5: What are Ansible Modules?

**Answer:**
**Ansible Modules** are reusable units of code that perform specific tasks on managed nodes . They are the building blocks of Ansible automation.

**Module categories** :
- **Core modules**: Maintained by the Ansible project, bundled with distribution, receive priority fixes
- **Community/extra modules**: Maintained by the community, may move to core over time

**Common modules** :
- `apt` / `yum` / `dnf`: Package management
- `copy`: Copy files to remote hosts
- `service` / `systemd`: Manage services
- `file`: Manage files and directories
- `template`: Deploy Jinja2 templates
- `git`: Manage Git repositories
- `uri`: Interact with web APIs

**Module example**:
```yaml
- name: Ensure nginx is installed
  apt:
    name: nginx
    state: present
```

### Q6: Explain the concept of 'idempotence' in Ansible

**Answer:**
**Idempotence** means that an operation can be applied multiple times without changing the system state beyond the initial application . If a resource is already in the desired state, Ansible detects this and makes no changes .

**Why idempotence matters** :
- **Safety**: Running playbooks repeatedly won't cause unintended changes
- **Predictability**: System remains in consistent state
- **Efficiency**: Only changed tasks report "changed" status
- **Reliability**: Enables partial runs and retries without fear

**Example of idempotent vs. non-idempotent tasks**:

**Non-idempotent** (adds line every time):
```yaml
- name: Add line to file (not idempotent)
  shell: echo "new config" >> /etc/app.conf
```

**Idempotent** (adds only if not present):
```yaml
- name: Add line to file if not present (idempotent)
  lineinfile:
    path: /etc/app.conf
    line: "new config"
    state: present
```

### Q7: What are Ansible Roles?

**Answer:**
**Ansible Roles** provide a structured way to organize related content (tasks, handlers, templates, files, variables) into reusable and shareable units . They promote modularity, reusability, and maintainability .

**Role directory structure** :
```
rolename/
  â”œâ”€â”€ tasks/
  â”‚   â””â”€â”€ main.yml        # Main list of tasks
  â”œâ”€â”€ handlers/
  â”‚   â””â”€â”€ main.yml        # Handlers
  â”œâ”€â”€ templates/
  â”‚   â””â”€â”€ ...             # Jinja2 templates
  â”œâ”€â”€ files/
  â”‚   â””â”€â”€ ...             # Static files
  â”œâ”€â”€ vars/
  â”‚   â””â”€â”€ main.yml        # Role variables (high precedence)
  â”œâ”€â”€ defaults/
  â”‚   â””â”€â”€ main.yml        # Default variables (lowest precedence)
  â”œâ”€â”€ meta/
  â”‚   â””â”€â”€ main.yml        # Role dependencies
  â””â”€â”€ README.md           # Documentation
```

**Using roles in playbooks** :
```yaml
- hosts: webservers
  roles:
    - role: nginx
    - role: geerlingguy.php
```

### Q8: What are Ansible Facts?

**Answer:**
**Ansible Facts** are pieces of information about target systems that Ansible automatically discovers at the beginning of playbook runs . They're gathered using the `setup` module and stored as variables.

**Types of facts** :
- Operating system details
- IP addresses and network interfaces
- Memory and CPU information
- Disk space and mount points
- Hardware details
- Environment variables

**Using facts in playbooks**:
```yaml
- hosts: all
  tasks:
    - name: Print operating system
      debug:
        msg: "This system runs {{ ansible_distribution }} {{ ansible_distribution_version }}"
    
    - name: Install package based on OS
      package:
        name: httpd
        state: present
      when: ansible_os_family == "RedHat"
```

**Controlling fact gathering** :
```yaml
- hosts: all
  gather_facts: no   # Disable fact gathering for speed
```

### Q9: What are Ansible Handlers?

**Answer:**
**Ansible Handlers** are special tasks that run only when notified by other tasks . They're typically used for actions that should occur only after a change, like restarting a service after a configuration file update .

**How handlers work** :
1. A task includes a `notify` directive pointing to a handler name
2. When that task reports a "changed" status, it triggers the handler
3. Handlers run once at the end of the play, even if notified multiple times

**Example**:
```yaml
- hosts: webservers
  tasks:
    - name: Update nginx configuration
      template:
        src: nginx.conf.j2
        dest: /etc/nginx/nginx.conf
      notify: restart nginx    # Triggers handler if file changed
  
  handlers:
    - name: restart nginx
      service:
        name: nginx
        state: restarted
```

### Q10: What is Ansible Vault?

**Answer:**
**Ansible Vault** is a feature that encrypts sensitive data like passwords, API keys, or private keys within Ansible playbooks or roles . It ensures confidential information is stored securely in version control .

**Common commands** :
```bash
# Encrypt a file
ansible-vault encrypt secrets.yml

# Create a new encrypted file
ansible-vault create vault.yml

# View encrypted file
ansible-vault view secrets.yml

# Edit encrypted file
ansible-vault edit secrets.yml

# Decrypt permanently
ansible-vault decrypt secrets.yml
```

**Using encrypted variables in playbooks** :
```yaml
- hosts: all
  vars_files:
    - secrets.yml
  tasks:
    - name: Use secret API key
      uri:
        url: "https://api.example.com/data"
        headers:
          Authorization: "Bearer {{ api_key }}"
```

**Running playbooks with vault** :
```bash
# Prompt for password
ansible-playbook playbook.yml --ask-vault-pass

# Use password file
ansible-playbook playbook.yml --vault-password-file vault.pass
```

---

## Intermediate Ansible Questions

### Q11: What are Ansible Templates and Jinja2?

**Answer:**
**Ansible Templates** are files that use the **Jinja2** templating language to generate dynamic configuration files during playbook execution . They allow you to inject variables and logic into configuration files.

**Template example** (`nginx.conf.j2`):
```jinja2
server {
    listen {{ http_port }};
    server_name {{ server_name }};
    
    root {{ web_root }};
    
    {% if enable_ssl %}
    listen 443 ssl;
    ssl_certificate {{ ssl_cert_path }};
    ssl_certificate_key {{ ssl_key_path }};
    {% endif %}
}
```

**Using templates in playbooks**:
```yaml
- name: Deploy nginx configuration
  template:
    src: nginx.conf.j2
    dest: /etc/nginx/nginx.conf
  notify: restart nginx
```

**Jinja2 features**:
- Variable substitution: `{{ variable_name }}`
- Conditionals: `{% if condition %} ... {% endif %}`
- Loops: `{% for item in list %} ... {% endfor %}`
- Filters: `{{ variable | upper }}`, `{{ list | join(', ') }}`

### Q12: Explain Ansible variable precedence

**Answer:**
Ansible has a well-defined **variable precedence hierarchy** that determines which variable value wins when the same variable is defined in multiple places .

**Simplified precedence order (lowest to highest)** :
1. Role defaults (lowest)
2. Inventory variables (group_vars, host_vars)
3. Playbook vars (vars, vars_files, vars_prompt)
4. Task-level vars (include_vars, set_fact)
5. Extra vars (passed with `-e`) â€” **highest priority**

**Complete ladder concept**: The full list has over 20 levels, but the key principle is: **extra vars always win, role defaults always lose** .

**Common pitfalls** :
- **Unintended overrides**: Defining variables in multiple places can lead to unexpected behavior
- **Using role defaults instead of vars**: Defaults are weak and can be overridden by inventory
- **Forgetting about set_fact**: `set_fact` creates host-level variables that persist throughout the play
- **Mixing host_vars and group_vars**: Host-level always overrides group-level

### Q13: What are Ansible Loops and how are they used?

**Answer:**
**Ansible Loops** allow you to iterate over data structures (lists, dictionaries) to perform repetitive tasks efficiently . They help reduce code duplication.

**Loop syntax** (modern vs. legacy) :

**Modern syntax (preferred)**:
```yaml
- name: Install multiple packages
  apt:
    name: "{{ item }}"
    state: present
  loop:
    - nginx
    - git
    - curl
```

**Loop over dictionaries**:
```yaml
- name: Create multiple users
  user:
    name: "{{ item.name }}"
    uid: "{{ item.uid }}"
    shell: "{{ item.shell }}"
  loop:
    - { name: 'alice', uid: 1001, shell: '/bin/bash' }
    - { name: 'bob', uid: 1002, shell: '/bin/zsh' }
```

**Loop with conditionals**:
```yaml
- name: Create directories if they don't exist
  file:
    path: "{{ item }}"
    state: directory
  loop:
    - /app/data
    - /app/logs
    - /app/config
  when: not item.startswith('/app/logs')  # Skip logs directory
```

**Legacy syntax** (`with_items`, `with_dict`, etc.) is still supported but `loop` is preferred for most cases.

### Q14: What are Ansible Conditionals?

**Answer:**
**Ansible Conditionals** control the execution flow of playbooks based on specific conditions using the `when` statement . They enable dynamic responses to varying scenarios.

**Basic conditional example**:
```yaml
- name: Install Apache on Debian/Ubuntu
  apt:
    name: apache2
    state: present
  when: ansible_os_family == "Debian"

- name: Install Apache on RHEL/CentOS
  yum:
    name: httpd
    state: present
  when: ansible_os_family == "RedHat"
```

**Multiple conditions**:
```yaml
- name: Configure application
  template:
    src: app.conf.j2
    dest: /etc/app.conf
  when: 
    - ansible_distribution == "Ubuntu"
    - ansible_distribution_version >= "20.04"
```

**Conditionals with variables**:
```yaml
- name: Restart service only if configuration changed
  service:
    name: nginx
    state: restarted
  when: nginx_conf.changed  # Based on registered variable
```

### Q15: What are registered variables?

**Answer:**
**Registered variables** capture the output of a task so it can be used later in the playbook . They store module return values, including stdout, stderr, and status.

**Example** :
```yaml
- name: Check if a file exists
  ansible.builtin.stat:
    path: /etc/passwd
  register: file_info

- name: Print the result
  debug:
    msg: "File exists: {{ file_info.stat.exists }}"

- name: Conditional based on registered output
  command: /usr/bin/some_command
  when: file_info.stat.exists
```

**Common registered variable fields**:
- `rc`: Return code
- `stdout`: Standard output
- `stderr`: Standard error
- `changed`: Whether task made changes
- `failed`: Whether task failed

**Advanced usage**:
```yaml
- name: Run script
  command: /tmp/deploy.sh
  register: result
  failed_when: 
    - result.rc != 0
    - '"ERROR" in result.stderr'
```

### Q16: What are Ansible Tags?

**Answer:**
**Ansible Tags** are labels assigned to tasks, plays, or roles that allow selective execution of specific parts of a playbook . They provide granular control over automation actions.

**Assigning tags**:
```yaml
- hosts: all
  tasks:
    - name: Install packages
      apt:
        name: nginx
        state: present
      tags: [packages, nginx, install]

    - name: Configure nginx
      template:
        src: nginx.conf.j2
        dest: /etc/nginx/nginx.conf
      tags: [configuration, nginx]
      
    - name: Start service
      service:
        name: nginx
        state: started
      tags: [service, nginx]
```

**Using tags at runtime** :
```bash
# Run only tasks with 'configuration' tag
ansible-playbook playbook.yml --tags "configuration"

# Skip tasks with 'packages' tag
ansible-playbook playbook.yml --skip-tags "packages"

# List all tags in playbook
ansible-playbook playbook.yml --list-tags
```

**Tag inheritance**: Tags applied to plays or roles are inherited by all tasks within them.

### Q17: What are Ansible Filters?

**Answer:**
**Ansible Filters** (powered by Jinja2) manipulate data during playbook execution . They transform, format, or modify data for use in tasks.

**Common filters** :

**String filters**:
```yaml
- debug:
    msg: "{{ 'hello world' | upper }}"  # HELLO WORLD

- debug:
    msg: "{{ '  padded  ' | trim }}"    # padded
```

**List filters**:
```yaml
- debug:
    msg: "{{ [1,2,3,4] | first }}"          # 1

- debug:
    msg: "{{ [1,2,3,4] | last }}"           # 4

- debug:
    msg: "{{ [3,1,4,2] | sort }}"           # [1,2,3,4]

- debug:
    msg: "{{ [1,2,3,4] | select('even') }}" # [2,4]
```

**Dictionary filters**:
```yaml
- debug:
    msg: "{{ {'a':1, 'b':2} | dict2items }}"  # [{'key':'a','value':1}, {'key':'b','value':2}]
```

**Default filter**:
```yaml
- debug:
    msg: "{{ undefined_var | default('default value') }}"
```

### Q18: What is Ansible Galaxy?

**Answer:**
**Ansible Galaxy** is a community hub for sharing and downloading Ansible roles and collections . It accelerates playbook development by providing reusable content created by the community and vendors .

**Key features** :
- Centralized repository for Ansible content
- Role discovery and sharing
- Version management
- Dependency resolution

**Ansible Galaxy commands** :
```bash
# Search for roles
ansible-galaxy search nginx

# Download and install a role
ansible-galaxy install geerlingguy.nginx

# List installed roles
ansible-galaxy list

# Remove a role
ansible-galaxy remove geerlingguy.nginx

# Initialize a new role structure
ansible-galaxy init my_custom_role
```

**Requirements file** :
```yaml
# requirements.yml
roles:
  - src: geerlingguy.nginx
    version: 3.1.0
  - src: geerlingguy.mysql
    version: 4.0.0

# Install all dependencies
ansible-galaxy install -r requirements.yml
```

### Q19: What are Ansible Collections and FQCNs?

**Answer:**
**Ansible Collections** are a distribution format introduced in Ansible 2.9 for packaging and distributing Ansible content . They bundle not just roles, but also modules, plugins, playbooks, and documentation .

**What Collections contain** :
- Modules
- Plugins
- Roles
- Playbooks
- Documentation

**FQCN (Fully Qualified Collection Name)** uniquely identifies a module or plugin by specifying its collection :
```
namespace.collection.module_name
```

**Example** :
```yaml
# Using FQCN in tasks
- name: Use git module from community.general
  community.general.git:
    repo: https://github.com/example/repo.git
    dest: /app/repo
```

**Requirements file for Collections** :
```yaml
# requirements.yml
collections:
  - name: community.general
    version: 7.8.0
  - name: ansible.posix
    version: 1.3.0

# Install collections
ansible-galaxy collection install -r requirements.yml
```

### Q20: What is Ansible Tower/AWX?

**Answer:**
**Ansible Tower** (commercial) and **AWX** (open-source upstream) are web-based UI platforms for managing Ansible projects at scale . They provide enterprise features beyond the command-line interface.

**Key features** :
- **Role-based access control (RBAC)**: Fine-grained permissions for users and teams
- **Job scheduling**: Run playbooks on defined schedules
- **Centralized logging**: Consolidated view of all automation runs
- **Inventory management**: Graphical inventory management
- **REST API**: Programmatic access to all features
- **Workflow visualization**: Visual representation of complex workflows

**Benefits over raw Ansible CLI** :
- Scalability for large teams
- Audit trails and compliance reporting
- Integration with external authentication (LDAP, SAML)
- Self-service for different teams
- Better visibility into automation status

**Use cases** :
- Enterprise-wide automation governance
- Multi-team collaboration
- Scheduled compliance checks
- Approval workflows for production changes

---

## Advanced Ansible Questions

### Q21: Explain Ansible's push vs. pull model and when to use ansible-pull

**Answer:**
Ansible primarily operates in a **push model**, where the control node pushes configurations to managed nodes over SSH . However, Ansible also supports a **pull model** using `ansible-pull` .

**Push model (default)** :
- Control node initiates connections to managed nodes
- Best for central management scenarios
- Suitable for most use cases

**Pull model (ansible-pull)** :
- Managed nodes pull configuration from a central repository (like Git)
- Nodes apply configuration locally
- Nodes run on a schedule (cron)

**When to use ansible-pull** :
- **Decentralized environments**: Large numbers of nodes not always reachable from control node
- **Ephemeral infrastructure**: Nodes that come and go frequently
- **Scale considerations**: Reduces load on central control node
- **Network constraints**: Nodes behind firewalls or with intermittent connectivity

**Example ansible-pull command**:
```bash
ansible-pull -U https://github.com/company/ansible-config.git playbook.yml
```

**Cron setup for pull model**:
```bash
# Run every hour
0 * * * * /usr/bin/ansible-pull -U https://github.com/company/ansible-config.git playbook.yml >> /var/log/ansible-pull.log
```

### Q22: How do you optimize Ansible performance for large-scale deployments?

**Answer:**
Optimizing Ansible performance for large-scale deployments requires multiple strategies .

**Key optimization techniques** :

| Technique | Description | Configuration |
|-----------|-------------|---------------|
| **Increase forks** | Run tasks in parallel on multiple hosts | `ansible-playbook -f 20` or `forks=20` in ansible.cfg |
| **Enable pipelining** | Reduce SSH operations by pipelining | `pipelining = True` in ansible.cfg |
| **Fact caching** | Store facts to avoid re-gathering | `fact_caching = jsonfile` with timeout |
| **Disable fact gathering** | Skip fact collection when not needed | `gather_facts: false` at play level |
| **Use `strategy: free`** | Non-blocking execution | `strategy: free` in playbook |
| **Limit scope** | Target only necessary hosts | `--limit webservers` |

**Example ansible.cfg optimizations**:
```ini
[defaults]
forks = 20
gathering = smart
fact_caching = jsonfile
fact_caching_connection = /tmp/ansible_facts
fact_caching_timeout = 7200
internal_poll_interval = 0.001

[ssh_connection]
pipelining = True
ssh_args = -o ControlMaster=auto -o ControlPersist=60s
```

**Asynchronous tasks** :
```yaml
- name: Long running task
  command: /path/to/long_running_command
  async: 3600
  poll: 0
  register: long_task

- name: Wait for long running task to finish
  async_status:
    jid: "{{ long_task.ansible_job_id }}"
  register: job_result
  until: job_result.finished
  retries: 30
  delay: 60
```

### Q23: What are Ansible Strategies and how do they control task execution?

**Answer:**
**Ansible Strategies** define how tasks are executed across multiple hosts . They control the execution order and parallelism.

**Strategy types**:

| Strategy | Description | Use Case |
|----------|-------------|----------|
| **`linear` (default)** | All hosts execute each task before moving to next | Standard, predictable execution |
| **`free`** | Each host executes tasks independently | Faster execution, no synchronization needs |
| **`debug`** | Runs play in debugger mode | Troubleshooting |
| **`host_pinned`** | Tasks run on each host sequentially | When order matters per host |

**Example using free strategy**:
```yaml
- hosts: all
  strategy: free
  tasks:
    - name: This runs independently on each host
      command: /opt/long_running_task.sh
      
    - name: This may run at different times per host
      debug:
        msg: "Task complete"
```

**Custom strategies**: Advanced users can create custom strategies by developing Python plugins.

### Q24: How do you implement error handling and recovery in Ansible?

**Answer:**
Ansible provides multiple mechanisms for robust error handling and recovery .

**1. ignore_errors** :
```yaml
- name: Non-critical task
  command: /bin/false
  ignore_errors: yes
```

**2. failed_when** :
```yaml
- name: Run script
  command: /tmp/deploy.sh
  register: result
  failed_when: 
    - result.rc != 0
    - '"FATAL" in result.stderr'
```

**3. changed_when**:
```yaml
- name: Run custom script
  command: /tmp/update.sh
  register: result
  changed_when: '"UPDATED" in result.stdout'
```

**4. Retries and until** :
```yaml
- name: Retry task until successful
  uri:
    url: https://api.example.com/health
  register: result
  until: result.status == 200
  retries: 5
  delay: 10
```

**5. Block, rescue, always** :
```yaml
- name: Structured error handling
  block:
    - name: Task that might fail
      command: /bin/false
      
  rescue:
    - name: Handle failure
      debug:
        msg: "Task failed - performing recovery"
    - name: Rollback changes
      include_tasks: rollback.yml
      
  always:
    - name: Always run cleanup
      file:
        path: /tmp/working_dir
        state: absent
```

### Q25: What are delegate_to and run_once and when would you use them?

**Answer:**
`delegate_to` and `run_once` control where and how many times tasks execute .

**delegate_to**: Executes a task on a different host than the one being processed .

**Use cases**:
- Managing load balancers during deployments
- Updating central monitoring systems
- Registering nodes in a service registry

**Example** :
```yaml
- hosts: webservers
  tasks:
    - name: Drain traffic from web server
      uri:
        url: "http://loadbalancer/api/drain/{{ inventory_hostname }}"
        method: POST
      delegate_to: localhost
      
    - name: Update web server
      include_role:
        name: web
```

**run_once**: Ensures a task executes only once, on the first host in the current batch .

**Use cases**:
- Initializing shared resources
- Creating databases
- Sending notifications

**Example**:
```yaml
- hosts: databases
  tasks:
    - name: Create database cluster
      command: /usr/bin/create_cluster
      run_once: true
      
    - name: Configure each node
      command: /usr/bin/configure_node
```

**Combining both**:
```yaml
- name: Register all servers in load balancer
  uri:
    url: "http://loadbalancer/api/register/{{ groups.webservers | join(',') }}"
    method: POST
  run_once: true
  delegate_to: localhost
```

### Q26: What are dynamic inventories and how do you implement them?

**Answer:**
**Dynamic inventories** are scripts or plugins that generate inventory data on the fly from external sources . They're essential for managing dynamic cloud infrastructure.

**Sources for dynamic inventory** :
- Cloud providers (AWS EC2, Azure, GCP)
- CMDBs
- Virtualization platforms
- Container orchestrators (Kubernetes)

**AWS EC2 dynamic inventory example** :

Install requirements:
```bash
pip install boto boto3
```

Create inventory file (`aws_ec2.yml`):
```yaml
plugin: aws_ec2
regions:
  - us-east-1
  - us-west-2
filters:
  tag:Environment: production
  instance-state-name: running
keyed_groups:
  - key: tags.Role
    prefix: role
  - key: placement.region
    prefix: region
```

Use the dynamic inventory:
```bash
ansible-playbook -i aws_ec2.yml playbook.yml
```

**Benefits** :
- Automatically tracks infrastructure changes
- No manual inventory updates
- Enables auto-scaling integration
- Groups by tags, regions, or custom attributes

### Q27: How do you implement rolling updates with zero downtime?

**Answer:**
Rolling updates with zero downtime ensure service availability while updating servers .

**Key components** :
1. Load balancer to manage traffic
2. `serial` keyword to control batch size
3. Health checks to verify success
4. Load balancer API integration

**Example playbook** :
```yaml
- hosts: web_servers
  serial: 2  # Update 2 servers at a time
  tasks:
    - name: Drain traffic from web server
      uri:
        url: "http://loadbalancer/api/drain/{{ inventory_hostname }}"
        method: POST
      delegate_to: localhost

    - name: Update web server
      include_role:
        name: web

    - name: Perform health check
      uri:
        url: "http://{{ inventory_hostname }}/health"
        status_code: 200
        retries: 5
        delay: 10
      register: health_check

    - name: Add web server back to load balancer
      uri:
        url: "http://loadbalancer/api/add/{{ inventory_hostname }}"
        method: POST
      delegate_to: localhost
      when: health_check.status == 200
```

**Advanced serial options** :
```yaml
- hosts: web_servers
  serial: 
    - 1       # First batch: 1 server
    - 3       # Second batch: 3 servers
    - 5       # Third batch: 5 servers
    - "20%"   # Then 20% at a time
```

### Q28: How do you integrate Ansible with CI/CD pipelines?

**Answer:**
Ansible integrates with CI/CD tools like Jenkins, GitLab CI, and GitHub Actions to automate deployment pipelines .

**GitLab CI example** :
```yaml
# .gitlab-ci.yml
stages:
  - test
  - deploy

variables:
  ANSIBLE_HOST_KEY_CHECKING: "false"

before_script:
  - apt-get update -qq && apt-get install -y -qq ansible
  - mkdir -p ~/.ssh
  - echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
  - chmod 600 ~/.ssh/id_rsa

test:
  stage: test
  script:
    - ansible-playbook -i inventory/staging playbook.yml --check --diff

deploy_staging:
  stage: deploy
  script:
    - ansible-playbook -i inventory/staging playbook.yml
  only:
    - develop

deploy_production:
  stage: deploy
  script:
    - ansible-playbook -i inventory/production playbook.yml
  when: manual
  only:
    - main
```

**Jenkins pipeline example** :
```groovy
pipeline {
    agent any
    stages {
        stage('Checkout') {
            steps { checkout scm }
        }
        stage('Syntax Check') {
            steps {
                sh 'ansible-playbook playbook.yml --syntax-check'
            }
        }
        stage('Dry Run') {
            steps {
                withCredentials([file(credentialsId: 'vault-password', variable: 'VAULT_PASS')]) {
                    sh 'ansible-playbook -i inventory/staging playbook.yml --check --diff --vault-password-file $VAULT_PASS'
                }
            }
        }
        stage('Deploy') {
            input {
                message "Deploy to production?"
                ok "Yes"
            }
            steps {
                withCredentials([file(credentialsId: 'vault-password', variable: 'VAULT_PASS')]) {
                    sh 'ansible-playbook -i inventory/production playbook.yml --vault-password-file $VAULT_PASS'
                }
            }
        }
    }
}
```

**Secrets management in CI/CD** :
- Use CI/CD secrets store for vault passwords
- Retrieve from HashiCorp Vault or AWS Secrets Manager
- Never hardcode secrets in pipeline configuration

### Q29: What are Ansible Callback Plugins?

**Answer:**
**Ansible Callback Plugins** customize the output presentation during playbook runs and integrate with external systems . They trigger actions at various points during playbook execution.

**Common callback types** :

| Callback Plugin | Purpose |
|-----------------|---------|
| `profile_tasks` | Shows timing for each task |
| `timer` | Displays total playbook runtime |
| `slack` | Sends notifications to Slack |
| `mail` | Emails playbook results |
| `log_plays` | Logs output to files |
| `datadog` | Sends metrics to Datadog |
| `grafana_annotations` | Creates annotations in Grafana |

**Enabling callbacks** in `ansible.cfg`:
```ini
[defaults]
stdout_callback = profile_tasks
callback_whitelist = timer, mail, profile_tasks
```

**Custom callback plugin example** (`custom_notify.py`):
```python
from ansible.plugins.callback import CallbackBase

class CallbackModule(CallbackBase):
    CALLBACK_VERSION = 2.0
    CALLBACK_TYPE = 'notification'
    CALLBACK_NAME = 'custom_notify'

    def v2_playbook_on_stats(self, stats):
        """Called after playbook completes"""
        hosts = sorted(stats.processed.keys())
        for host in hosts:
            summary = stats.summarize(host)
            if summary['failures'] > 0 or summary['unreachable'] > 0:
                self._display.display(f"âš ï¸ {host} FAILED: {summary}")
            else:
                self._display.display(f"âœ… {host} SUCCEEDED")
```

### Q30: How do you create custom modules and plugins in Ansible?

**Answer:**
Custom modules and plugins extend Ansible's functionality for specific organizational needs .

**Custom module structure**:
```python
#!/usr/bin/python

from ansible.module_utils.basic import AnsibleModule

def main():
    module = AnsibleModule(
        argument_spec=dict(
            name=dict(type='str', required=True),
            state=dict(type='str', choices=['present', 'absent'], default='present'),
            config=dict(type='dict', required=False)
        ),
        supports_check_mode=True
    )

    name = module.params['name']
    state = module.params['state']
    config = module.params.get('config', {})

    result = dict(
        changed=False,
        original_message=name,
        message=''
    )

    # Check mode - preview changes without executing
    if module.check_mode:
        if state == 'present':
            result['message'] = f"Would create resource {name}"
            result['changed'] = True
        else:
            result['message'] = f"Would delete resource {name}"
            result['changed'] = True
        module.exit_json(**result)

    # Actual implementation
    if state == 'present':
        # Create or update logic
        result['message'] = f"Resource {name} created"
        result['changed'] = True
    else:
        # Delete logic
        result['message'] = f"Resource {name} deleted"
        result['changed'] = True

    module.exit_json(**result)

if __name__ == '__main__':
    main()
```

**Directory structure for custom content**:
```
ansible_collections/
  â””â”€â”€ mynamespace/
      â””â”€â”€ mycollection/
          â”œâ”€â”€ plugins/
          â”‚   â”œâ”€â”€ modules/
          â”‚   â”‚   â””â”€â”€ my_custom_module.py
          â”‚   â”œâ”€â”€ callback/
          â”‚   â”‚   â””â”€â”€ my_callback.py
          â”‚   â””â”€â”€ inventory/
          â”‚       â””â”€â”€ my_inventory.py
          â”œâ”€â”€ roles/
          â””â”€â”€ galaxy.yml
```

**Using custom modules**:
```yaml
- name: Use custom module
  mynamespace.mycollection.my_custom_module:
    name: "my-resource"
    state: present
    config:
      key: value
```

**Testing custom modules**:
```bash
# Test module directly
python -m my_custom_module '{"name": "test", "state": "present"}'

# Test with ansible
ansible localhost -m my_custom_module -a "name=test state=present"
```

---

## Ansible Scenario-Based Questions

### Q31: Multi-Tier Application Deployment

**Scenario:** You need to deploy a multi-tier application consisting of a web server, application server, and database server .

**Question:** How would you design your Ansible playbooks and roles to handle this deployment efficiently?

**Answer:**
I would use a **modular approach with Ansible roles** for each tier :

**Directory structure**:
```
site.yml
roles/
  web/
    tasks/
      main.yml
    templates/
      web.conf.j2
  app/
    tasks/
      main.yml
    templates/
      app.conf.j2
  db/
    tasks/
      main.yml
    templates/
      db.conf.j2
inventory/
  production/
    hosts
    group_vars/
      all.yml
      web.yml
      app.yml
      db.yml
```

**site.yml** :
```yaml
- hosts: web
  roles:
    - role: web

- hosts: app
  roles:
    - role: app

- hosts: db
  roles:
    - role: db
```

**Benefits**:
- **Separation of concerns**: Each tier independently managed
- **Reusability**: Roles can be reused across environments
- **Scalability**: Easy to add new servers to any tier
- **Maintainability**: Changes isolated to specific roles

### Q32: Handling Configuration Drift

**Scenario:** Over time, server configurations drift from the desired state defined in Ansible playbooks .

**Question:** How do you ensure servers remain in the desired state?

**Answer:**
Implement **regular configuration enforcement** using multiple strategies :

**1. Scheduled runs with cron/AWX**:
```bash
# Daily configuration enforcement
0 2 * * * ansible-playbook -i inventory site.yml --tags=config
```

**2. Ansible Tower/AWX schedules**:
- Set up job templates with schedules
- Configure notifications for failures
- Maintain audit trails

**3. Check mode for drift detection**:
```bash
# Detect drift without making changes
ansible-playbook -i inventory site.yml --check --diff --tags=config
```

**4. Idempotent playbook design**:
```yaml
- name: Enforce file permissions
  file:
    path: /etc/app/config
    owner: appuser
    group: appgroup
    mode: '0644'
  # Always enforces, only changes if needed
```

**5. GitOps approach**:
- Store desired state in Git
- CI/CD pipeline runs enforcement
- Automatic rollback on failures
- Change approval workflows

### Q33: Troubleshooting Playbook Failures

**Scenario:** Your playbook worked previously, but now it's failing .

**Question:** Describe your approach to troubleshooting a failing playbook that worked previously.

**Answer:**
A systematic troubleshooting approach :

**1. Check recent changes** :
```bash
git diff  # Review playbook changes
git log   # Check commit history
```

**2. Increase verbosity** :
```bash
ansible-playbook playbook.yml -vvv  # Maximum verbosity
```

**3. Syntax check** :
```bash
ansible-playbook playbook.yml --syntax-check
```

**4. Isolate the issue** :
```bash
# Run from specific task
ansible-playbook playbook.yml --start-at-task="Task Name"

# Step through tasks
ansible-playbook playbook.yml --step
```

**5. Use debug module** :
```yaml
- name: Print variable value
  debug:
    var: my_variable
    verbosity: 2
```

**6. Check environment consistency** :
```bash
ansible --version                # Ansible version
ansible-inventory --list         # Verify inventory
ansible all -m ping              # Connectivity check
```

**7. Check logs** :
- Target system logs (`/var/log/syslog`, `/var/log/messages`)
- Application-specific logs
- Ansible log (if configured)

### Q34: Managing Secrets in CI/CD Pipelines

**Scenario:** You need to integrate Ansible with CI/CD pipelines while managing secrets securely .

**Question:** How do you handle sensitive data like API keys or database passwords in automated pipelines?

**Answer:**
A comprehensive secrets management strategy for CI/CD :

**1. Ansible Vault for encryption at rest** :
```bash
# Encrypt sensitive variables
ansible-vault encrypt group_vars/production/vault.yml
```

**vault.yml**:
```yaml
vault_db_password: SuperSecret123
vault_api_key: abc123def456
```

**2. CI/CD secrets management** :

**GitLab CI example**:
```yaml
variables:
  ANSIBLE_VAULT_PASSWORD: $VAULT_PASS  # From CI/CD secrets

before_script:
  - echo $ANSIBLE_VAULT_PASSWORD > .vault_pass
  - chmod 600 .vault_pass

deploy:
  script:
    - ansible-playbook -i inventory/production site.yml --vault-password-file .vault_pass
  after_script:
    - rm .vault_pass
```

**Jenkins example** :
```groovy
withCredentials([file(credentialsId: 'vault-password', variable: 'VAULT_PASS')]) {
    sh 'ansible-playbook -i inventory/production site.yml --vault-password-file $VAULT_PASS'
}
```

**3. External secret managers** :
- **HashiCorp Vault**: Dynamic database credentials
- **AWS Secrets Manager**: Rotating secrets
- **Azure Key Vault**: Integration with Azure services

**HashiCorp Vault lookup example**:
```yaml
- name: Get database password from Vault
  set_fact:
    db_password: "{{ lookup('hashi_vault', 'secret/data/db:password') }}"
```

**4. Best practices** :
- Never hardcode secrets in playbooks
- Use different secrets per environment
- Rotate credentials regularly
- Audit secret access
- Limit who can decrypt vaults

### Q35: Optimizing Playbook Performance for Large Environments

**Scenario:** Your playbook takes too long to execute across hundreds of servers .

**Question:** How do you optimize Ansible playbook performance for large-scale deployments?

**Answer:**
A multi-faceted optimization approach :

**1. Increase parallelism** :
```bash
ansible-playbook -i inventory site.yml -f 50
```

**2. Enable SSH pipelining** :
```ini
[ssh_connection]
pipelining = True
ssh_args = -o ControlMaster=auto -o ControlPersist=60s
```

**3. Implement fact caching** :
```ini
[defaults]
gathering = smart
fact_caching = jsonfile
fact_caching_connection = /tmp/ansible_facts
fact_caching_timeout = 86400  # 24 hours
```

**4. Disable unnecessary fact gathering** :
```yaml
- hosts: all
  gather_facts: false  # When facts aren't needed
  
- hosts: all
  gather_facts: true
  tasks:
    - name: Use only specific fact
      setup:
        filter: ansible_os_family
```

**5. Use async tasks for long operations** :
```yaml
- name: Long database backup
  shell: /usr/bin/pg_dumpall > /backup/db.sql
  async: 3600
  poll: 0
  register: backup_job

- name: Wait for backup to complete
  async_status:
    jid: "{{ backup_job.ansible_job_id }}"
  register: job_result
  until: job_result.finished
  retries: 60
  delay: 60
```

**6. Optimize task design** :
- Use `serial` for controlled batches
- Delegate tasks appropriately
- Minimize `shell`/`command` modules
- Use native Ansible modules

**7. Performance metrics** :
```bash
# Profile tasks
ansible-playbook site.yml --timeout=30 -f 20
```

**8. Mitogen optimization** (advanced):
- External strategy plugin for dramatic speedup
- Reduces overhead through connection pooling
- Can provide 1.25x to 7x speed improvement

---

## Ansible Commands Cheat Sheet

| Category | Command | Description |
|----------|---------|-------------|
| **Basic Commands** | `ansible --version` | Show Ansible version |
| | `ansible all -m ping` | Test connectivity to all hosts |
| | `ansible-inventory --list` | Display inventory contents |
| | `ansible-doc -l` | List available modules |
| | `ansible-doc module_name` | Show module documentation |
| **Playbook Execution** | `ansible-playbook playbook.yml` | Run a playbook |
| | `ansible-playbook playbook.yml --check` | Dry run (check mode) |
| | `ansible-playbook playbook.yml --diff` | Show file differences |
| | `ansible-playbook playbook.yml --syntax-check` | Validate syntax |
| | `ansible-playbook playbook.yml --step` | Step through tasks interactively |
| | `ansible-playbook playbook.yml --start-at-task="Task Name"` | Start from specific task |
| | `ansible-playbook playbook.yml --tags="tag1,tag2"` | Run only tagged tasks |
| | `ansible-playbook playbook.yml --skip-tags="tag1"` | Skip tagged tasks |
| | `ansible-playbook playbook.yml --limit hostgroup` | Limit to specific hosts |
| | `ansible-playbook playbook.yml -f 10` | Set forks (parallelism) |
| **Verbosity Levels** | `ansible-playbook playbook.yml -v` | Verbose (basic) |
| | `ansible-playbook playbook.yml -vv` | More verbose |
| | `ansible-playbook playbook.yml -vvv` | Very verbose (connection details) |
| | `ansible-playbook playbook.yml -vvvv` | Maximum verbosity (debug) |
| **Vault Commands** | `ansible-vault create file.yml` | Create encrypted file |
| | `ansible-vault encrypt file.yml` | Encrypt existing file |
| | `ansible-vault decrypt file.yml` | Decrypt file |
| | `ansible-vault view file.yml` | View encrypted file |
| | `ansible-vault edit file.yml` | Edit encrypted file |
| | `ansible-vault rekey file.yml` | Change vault password |
| **Galaxy Commands** | `ansible-galaxy search keyword` | Search for roles |
| | `ansible-galaxy install username.role` | Install a role |
| | `ansible-galaxy list` | List installed roles |
| | `ansible-galaxy remove username.role` | Remove a role |
| | `ansible-galaxy init role_name` | Create new role structure |
| | `ansible-galaxy collection install collection.name` | Install a collection |
| **Configuration** | `ansible-config list` | List all config options |
| | `ansible-config dump` | Show current configuration |
| | `ansible-config view` | View config file |
| **Ad-hoc Commands** | `ansible all -m setup` | Gather facts from all hosts |
| | `ansible all -m copy -a "src=/file dest=/file"` | Copy file to all hosts |
| | `ansible all -m apt -a "name=nginx state=latest"` | Install package |
| | `ansible all -m service -a "name=nginx state=started"` | Start service |
| | `ansible all -m command -a "uptime"` | Run command on all hosts |
| **Inventory** | `ansible-inventory --graph` | Show inventory graph |
| | `ansible-inventory --host hostname` | Show host variables |
| | `ansible-inventory --list --export` | Export inventory as JSON |
| **Debugging** | `ansible localhost -m debug -a "msg='Hello'"` | Debug message |
| | `ansible all -m ping -vvv` | Test with verbose output |
| | `ansible-playbook playbook.yml --profile-tasks` | Show task timing |

---

## ðŸ’¡ Tips for Ansible Interview Success

1. **Understand the fundamentals** - Be clear on agentless architecture, idempotence, and YAML syntax 
2. **Know the architecture** - Understand control nodes, managed nodes, inventory, and modules 
3. **Master Playbook and Role structure** - Be comfortable writing organized, reusable automation 
4. **Security mindset** - Demonstrate knowledge of Ansible Vault and secrets management 
5. **Performance optimization** - Understand fact caching, forks, pipelining for large environments 
6. **Troubleshooting approach** - Show systematic debugging methodology with verbosity levels 
7. **Integration knowledge** - Be familiar with CI/CD integration, dynamic inventories, and cloud providers 
8. **Real-world scenarios** - Practice with scenario-based questions like the ones above 
9. **Stay current** - Know about Collections, FQCNs, and modern best practices 
10. **Hands-on practice** - The best way to learn Ansible is to use it. Set up test environments and experiment 

Good luck with your Ansible interview! ðŸš€